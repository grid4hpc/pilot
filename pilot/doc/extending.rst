==================
 Расширения Pilot
==================

Устройство Pilot
================

Сервис pilot можно рассматривать как систему из нескольких компонентов:

* внешний интерфейс (``pilot.controllers``)
* система обработки заданий (``pilot.spooler.jobs``)
* система запуска и отслеживания задач (``pilot.spooler.tasks``)
* система подбора ресурсов (``pilot.spooler.matchmaker``)

Компоненты запуска и отслеживания задач, а также система подбора
ресурсов оперируют с *доменами* (realm). Каждый домен реализован как
набор классов, реализующих некоторый стандартный интерфейс, описанный
в ``pilot.api``, а именно интерфейсы ``IResourceEnumerator`` и
``ITaskExecutor``. Назначение интерфейса ``IResourceEnumerator`` —
предоставление системе подбора ресурсов информации о ресурсах,
доступных через данный домен. Назначение ``ITaskExecutor`` — запуск на
выполнение задач на ресурсы данного домена. 

Загрузка доменов
----------------

При старте сервис Pilot загружает домены, определяемые параметром
[common]/realms конфигурационного файла. Этот параметр содержит список
модулей, реализующих интерфейсы загружаемых доменов и, опционально, имена, которые будут использоваться для загруженных доменов.

Синтаксис этого параметра следующий (выражеиня в квадратных скобках
являются опциональными)::

  realms = realm_definition[, realm_definition[, ...]]

где ``realm_definition`` — определение домена, имеющее вид::

  module_name[(instance_name)]

Здесь ``module_name`` — имя модуля, а ``instance_name`` — имя
экземпляра домена. В том случае, если ``instance_name``, в качестве
него используется последний элеменет имени модуля. Все имена
``istance_name`` должны быть уникальными, и из алфвавита
``[a-zA-Z0-9_\-]``.

Порядок поиска модуля при загрузке доменов следующий: сначала делается
попытка загрузить модуль с именем
``pilot.spooler.realms.module_name``. Если такой модуль не существует,
то делается попытка загрузить модуль с именем ``module_name``.

Модуль домена должен содержать глобальный словарь ``config``
а также функцию ``load``. 

Словарь ``config`` является конфигурацией домена по умолчанию. Все
ключи и значения в этом словаре должны быть строками.  Функции
``load`` при вызове передается в качестве параметра действующая
конфигурация домена, получаемая следующим образом:

1. В качестве действующей конфигурации загружается конфигурация по
   умолчанию.
2. В конфигурационном файле pilot из секции, совпадающей с
   instance_name домена, считываются все ключи, совпадающие с
   названиями ключей конфигурации домена по умолчанию, и помещаются в
   соответствующие значения действующей конфигурации.

Функция ``load`` получает на вход единственный параметр — действующую
конфигурацию домена. Эта функция должна вернуть пару значений: объект,
реализующий интерфейс ``IResourceEnumerator`` и объект, реализующий
интерфейс ``ITaskExecutor``.

Обращаем внимание, что функция ``load`` имеет полное право возвращать
разные объекты в зависимости от конфигурации домена (это используется,
например, стандартным доменом ``gws``).

Стандартные домены
------------------

В комплекте с pilot уже есть стандартные домены: 

gws   
  запуск задач на ресурсы через WS-GRAM4 с использованием
  WS-MDS+GridNNN, Infosys2, либо статической конфигурации ресурсов в
  качестве поставщика информации о ресурсах.

gram5
  запуск задач на реусры через GRAM5 с использованием Infosys2, либо
  статической конфигурации ресурсов в качестве поставщика информации о
  ресурсах.

Еще несколько доменов находятся в разных стадиях реализации/тестирования:

glite
  запуск задач на ресурсы через gLite CREAM CE с использованием gLite
  BDII в качестве поставщика информации о ресурсах. Работоспособен в
  режиме proof of concept (Автор — Шмелькин).

pilot
  запуск задач как самостоятельных заданий на других сервисах pilot,
  поставщик информации пока только статический файл. В процессе разработки.

local
  запуск задач непосредственно на машине с сервисом pilot. В процессе
  разработки.

genbatch
  универсальный домен локальной batch-системы. Позволяет реализовать
  запуск на batch-системе, доступной сервису pilot непосредственно с
  той машины, на котрой он запущен. В процессе разработки.

Универсальный домен локальной batch-системы (genbatch)
======================================================

Данный домен предназначен для стыковки с batch-системами через внешние
интерфейсные программы, что позволяет писать стыки на любых языках
программирования.

Конфигурация genbatch
---------------------

Для использования genbatch необходимо создать новый модуль на Python,
который будет определять название нового домена. Минимальный модуль
имеет следующий вид:

::

    from pilot.spooler.realm.genbatch import config, load

    # параметры genbatch
    config["requires_x509"] = "no"

Фактически, все предназначение этого модуля состоит в том, чтобы
определить имя создаваемого домена и сконфигурировать genbatch.

Среда выполнения интерфейсных программ
--------------------------------------

Genbatch вызывает внешние программы для манипуляций с задачами. Ряд
конфигурационных опций влияет на среду выполнения программ, а также
работу genbatch. Далее приведен список конфигурационных параметров,
влияющих на среду выполнения программ.

* ``requires_x509``, default: *no*
  
  Если значение данного параметра *yes*, то:

  1. При запуске интерфейсных программ будет существовать действующий
     proxy-сертификат пользователя, его местоположение будет указано в
     переменной среде окружения ``X509_USER_PROXY``.

  2. При отсутствии действующей делегации сертификата для данного
     задания на сервисе, интерфейсные программы вызываться не будут,
     задачи всегда будут завершаться аварийно.

* ``map_user``, default: *yes*

  Если значение данного параметра *yes*, то сервис будет производить
  выбор локального пользователя в зависимости от делегации задания и
  запускать все интерфейсные программы с правами этого пользователя.

  При значении данного параметра *no*, запуск всех интерфейсных
  программ производится с правами пользователя, от которого запущен
  сервис pilot.

* ``map_sources``, default: *gridmap, voms*

  Список алгоритмов, которые используются для выбора локальных
  пользователей на основе прокси-сертификата. Используется первый
  алгоритм, вернувший определенный ответ о выборе
  пользователя. Определенным является ответ "разрешить доступ от
  локального пользователя или пула xxx" либо "запретить доступ".

  Доступные алгоритмы:

  - *ban*: запрет доступа для пользователей по списку.
  - *gridmap*: разрешение доступа для пользователей по списку.
  - *voms*: разрешение доступа для пользователей ВО по расширениям
     VOMS.

* ``gridmap_file``, default: */etc/grid-security/grid-mapfile*.

  Путь к файлу в формате globus grid-mapfile для алгоритма выбора
  пользователей gridmap.

* ``vomsmap_file``, default: */etc/grid-security/groupmapfile*

  Путь к файлу в формате LCMAPS groupmapfile для алгоритма выбора
  пользователей voms.

* ``ban_file``, default: нет

  Путь к файлу в формате одно имя сертификата на строку, содержащий
  список пользователей, для которых запрещен доступ при помощи
  алгоритма выбора пользователей ban.

* ``status_update_path``, default: нет

  Описание данного параметра см. в разделе :ref:`status-callbacks`.

* ``taskid_interface``, default: *arg*

  Если значение данного параметра *arg*, то команды ``status``,
  ``status_callback`` и ``kill`` получают идентификатор задачи в
  последнем аргументе командной строки. Если значение данного
  параметра *stdin*, то идентификатор задачи передается этим командам
  на stdin.

Интерфейсные программы
----------------------

Для функционирования домена необходим набор из четырех внешних
программ. Пути к ним прописываются в конфигурации в
``config["cmd_имя_команды"]``. Значения по умолчанию отсутствуют. 

В опциях ``config["timeout_имя_команды"]`` задается лимит на время
выполнения соответствующих команд в секундах. По умолчанию все
таймауты равны 15 секундам.

В опциях ``config["extra_args_имя_команды"]`` задаются дополнительные
аргументы, которые данная команда будет получать всегда (перед
аргументами, сгенерированными pilot).

Для работы genbatch необходимы по крайней мере программы
``pilot2batch``, ``submit`` и одна из ``status`` или
``status_callback``. При наличии одновременно ``status`` и
``status_callback``, испоьзуется только ``status``.

* ``pilot2batch``: программа, преобразующая описание задачи pilot с
  полностью разрешенными требованиями, путями и URLами файлов, в
  описание, понятное программе ``submit``. 

  Описание задачи в формате JSON попадает в stdin. В описании задачи
  будут полностью разрешены все требовния, пути к файлам и URLы
  (т.е. все они будут полными и/или абсолютными). Кроме того, в
  описании задачи будет дополнительный параметр ``internal_task_id``,
  содержащий внутренний идентификатор задачи системы pilot, который
  может быть использован для отправки уведомлений о состоянии задачи.

  Вывод этой программы интерпретируется следующим образом:

  - stdout: описание задачи. Будет передано на stdin программе ``submit``.
  - stderr: список дополнительных параметров для программы
    ``submit``. Отдельные параметры разделяются символом NULL (``'\x00'``).

  Как stdout, так и stderr являются опциональными.

  В случае кода завершения, отличного от 0, считается, что
  преобразование не удалось. При этом stdout содержит описание ошибки,
  которое получит пользователь, а stderr содержит описание ошибки,
  которое попадет в логи. Если stderr пустой, то в логи попадает
  содержимое stdout.

* ``submit``: программа запуска задач. Запускается с параметрами,
  определенными в конфигурации genbatch, а также с дополнительными
  параметрами, возвращенными ``pilot2batch``, если они были. На stdin
  получает описание, возвращенное ``pilot2batch``, если оно было.

  Данная программа на stdout должна вернуть идентификатор задачи,
  который будет передаваться программе ``status``. Содержимое stderr,
  если присутствует, может попасть в логи как информационное
  сообщение.

  В случае, если запуск не удался из-за стечения обстоятельств
  (например, произошел таймаут) программа должна завершиться с кодом 1.

  В случае, если запуск задачи с таким описанием данным пользователем
  наверняка не удастся, программа должна завершиться с кодом > 1.

  В случае кода завершения, отличного от 0, считается, что запуск не
  не удался. При этом stdout содержит описание ошибки, которое получит
  пользователь, а stderr содержит описание ошибки, которое попадет в
  логи. Если stderr пустой, то в логи попадает содержимое stdout.

* ``status``: программа проверки статуса задач. В зависимости от
  конфигурации genbatch, может получать идентификатор задачи либо на
  stdin либо в качестве параметра командной строки.

  Данная программа должна вернуть в stdout состояние задачи, с точки
  зрения Pilot, то есть одно из: PENDING, QUEUED, RUNNING, FINISHED,
  ABORTED.

  Содержимое stderr интерпретируется в зависимости от состояния
  задачи. Для задачи в состоянии FINISHED, stderr содержит код
  завершения задачи в виде строки в десятичной системе счисления и
  символ перевода строки. Дальнейшее содержимое stderr является
  информационным сообщением batch-системы. Для других состояний все
  содержимое stderr интерпретируется как информационное сообщение.

  В случае, если состояние задачи получить не удалось из-за стечения
  обстоятельств (например, произошел таймаут) программа должна
  завершиться с кодом 1.

  В случае, если состояние задачи с таким идентификатором получить
  наверняка не удастся (например, такой задачи не существует),
  программа должна завершиться с кодом > 1.

  В случае кода завершения, отличного от 0, считается, что получить
  состояние не удалось. При этом stdout содержит описание ошибки,
  которое получит пользователь, а stderr содержит описание ошибки,
  которое попадет в логи. Если stderr пустой, то в логи попадает
  содержимое stdout.

* ``status_callback``: программа проверки статуса задачи с отсылкой
  статуса через локальный HTTP-интерфейс. В зависимости от
  конфигурации genbatch, может получать идентификатор задачи либо на
  stdin либо в качестве параметра командной строки.

  Программа должна послать уведомление о текущем состоянии задачи и
  завершиться.

  В случае, если состояние задачи получить не удалось из-за стечения
  обстоятельств (например, произошел таймаут) программа должна
  завершиться с кодом 1.

  В случае, если состояние задачи с таким идентификатором получить
  наверняка не удастся (например, такой задачи не существует),
  программа должна завершиться с кодом > 1.

  В случае кода завершения, отличного от 0, считается, что получить
  состояние не удалось. При этом stdout содержит описание ошибки,
  которое получит пользователь, а stderr содержит описание ошибки,
  которое попадет в логи. Если stderr пустой, то в логи попадает
  содержимое stdout.

* ``kill``: программа остановки задач. В зависимости от
  конфигурации genbatch, может получать идентификатор задачи либо на
  stdin либо в качестве параметра командной строки.

  Данная программа должна "убить" задачу досрочно. Вне зависимости от
  ее кода завершения с точки зрения Pilot задача будет считаться
  убитой. Содержимое stderr, если оно было, попадет в логи.

.. _status-callbacks:

Уведомления о состоянии задач
-----------------------------

Если в конфигурации задан параметр ``config["status_update_path"]``,
имеющий значение *{something}*, то сервис pilot будет дополнительно
принимать уведомления о состоянии задач по протоколу HTTP. Уведомления
должны быть запросами методом PUT по одному из следующих адресов:

* pilot/status_updates/{something}/nid/{идентификатор_задачи}
* pilot/status_updates/{something}/pid/{внутренний_идентификатор_задачи}

Здесь:

- *{идентификатор_задчаи}* — "собственный" идентификатор
  batch-системы, возвращенный программой ``submit``;
- *{внутренний_идентификатор_задачи}* — внутренний идентификатор
  задачи в pilot, переданный в параметре описания ``internal_task_id``
  программе ``pilot2batch``.

Сами уведомления являются JSON-объектами, содержащими следующие атрибуты:

- *state*, строка: состояние задачи. Одно из PENDING, QUEUED,
  RUNNING, FINISHED, ABORTED.

- *cause*, строка, опционально: информация о текущем состоянии для
    пользователя.

- *exit_code*, число, опционально: код завершения программы.
